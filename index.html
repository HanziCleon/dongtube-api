<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>DongTube - Premium Anime Streaming</title>
<link rel="icon" type="image/png" href="https://b.top4top.io/p_35449hn0x0.jpg">
<link rel="stylesheet" href="style.css">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
<meta name="description" content="Stream thousands of anime series in HD quality. Watch your favorite anime with subtitles on DongTube - Premium Anime Streaming Platform.">
<meta name="keywords" content="anime, streaming, watch anime, anime online, HD anime, subtitle anime">
</head>
<body>

<!-- Animated Background -->
<div class="bg-animation">
  <div class="floating-orb orb-1"></div>
  <div class="floating-orb orb-2"></div>
  <div class="floating-orb orb-3"></div>
  <div class="floating-orb orb-4"></div>
  <div class="floating-orb orb-5"></div>
</div>

<!-- Navigation -->
<nav class="navbar">
  <div class="nav-container">
    <div class="nav-brand">
      <span class="brand-icon">üé¨</span>
      <span class="brand-text">DongTube</span>
    </div>
    <div class="nav-actions">
      <button id="themeSwitcher" class="nav-btn" title="Switch Theme">üåô</button>
    </div>
  </div>
</nav>

<!-- Hero Section -->
<section class="hero-section">
  <div class="hero-content">
    <h1 class="hero-title">
      <span class="gradient-text">Premium Anime</span>
      <span class="hero-subtitle">Streaming Experience</span>
    </h1>
    <p class="hero-description">Discover thousands of anime titles with HD quality streaming</p>
    <div class="hero-stats">
      <div class="stat-item">
        <div class="stat-number" id="animeCount">0</div>
        <div class="stat-label">Anime Series</div>
      </div>
      <div class="stat-item">
        <div class="stat-number">HD</div>
        <div class="stat-label">Quality</div>
      </div>
      <div class="stat-item">
        <div class="stat-number">24/7</div>
        <div class="stat-label">Available</div>
      </div>
    </div>
  </div>
</section>

<div class="container">
  <!-- Search Section -->
  <section class="search-section">
    <div class="search-header">
      <h2 class="section-title">Explore Anime Collection</h2>
      <div class="view-controls">
        <button id="gridView" class="view-btn active" title="Grid View">‚äû</button>
        <button id="listView" class="view-btn" title="List View">‚ò∞</button>
      </div>
    </div>
    
    <div class="search-wrapper">
      <div class="search-box">
        <input type="text" id="searchInput" placeholder="Search anime titles, genres...">
        <span class="search-icon">üîç</span>
      </div>
      
      <select id="filterSelect" class="filter-select">
        <option value="all">All Status</option>
        <option value="Ongoing">Ongoing</option>
        <option value="Complete">Complete</option>
      </select>
      
      <select id="sortSelect" class="sort-select">
        <option value="title">Sort by Title</option>
        <option value="status">Sort by Status</option>
        <option value="year">Sort by Year</option>
        <option value="rating">Sort by Rating</option>
      </select>
      
      <button id="resetBtn" class="reset-btn">Reset</button>
    </div>
  </section>

  <!-- Results Info -->
  <div class="results-info">
    <span id="resultCount">0</span> anime found
    <div id="loadingIndicator" class="loading-indicator" style="display:none;">
      <div class="spinner"></div>
      Loading...
    </div>
  </div>

  <!-- Anime Grid -->
  <div id="animeList" class="anime-grid"></div>

  <!-- Skeleton Loading -->
  <div id="skeletonWrapper" class="skeleton-grid"></div>

  <!-- No Results -->
  <div id="noResults" class="no-results" style="display:none;">
    <div class="no-results-icon">üòû</div>
    <h3>No anime found</h3>
    <p>Try different search terms or browse all anime</p>
    <button class="btn" onclick="resetFilters()">Browse All Anime</button>
  </div>
</div>

<!-- Footer -->
<footer class="footer">
  <div class="footer-content">
    <p>&copy; 2025 DongTube - Premium Anime Streaming</p>
    <div class="footer-links">
      <a href="#" class="footer-link">About</a>
      <a href="#" class="footer-link">Contact</a>
      <a href="#" class="footer-link">Privacy</a>
      <a href="/admin" class="footer-link">Admin</a>
    </div>
  </div>
</footer>

<!-- Toast Container -->
<div id="toast-container" class="toast-container"></div>

<script>
// JSONBin Configuration
const JSONBIN_URL = "https://api.jsonbin.io/v3/b/68c7fdc9d0ea881f407e85cc";
const JSONBIN_KEY = "$2a$10$PsVzgljojE5fq8qZRmpE4uzMr0K9LArqfmumGVSmNY.P8F2iTKrim";

// Global variables
let animeData = [];
let currentData = [];
let isGridView = true;
let isLoading = false;

// Theme Management
class ThemeManager {
  constructor() {
    this.currentTheme = localStorage.getItem('dongtube_theme') || 'dark';
    this.init();
  }

  init() {
    this.applyTheme(this.currentTheme);
    this.bindEvents();
  }

  applyTheme(theme) {
    document.documentElement.setAttribute('data-theme', theme);
    const themeIcon = document.querySelector('#themeSwitcher');
    if (themeIcon) {
      themeIcon.textContent = theme === 'dark' ? 'üåô' : '‚òÄÔ∏è';
    }
    this.currentTheme = theme;
    localStorage.setItem('dongtube_theme', theme);
  }

  toggle() {
    const newTheme = this.currentTheme === 'dark' ? 'light' : 'dark';
    this.applyTheme(newTheme);
    this.showToast(`Switched to ${newTheme} theme`, 'success');
  }

  bindEvents() {
    const themeSwitcher = document.getElementById('themeSwitcher');
    if (themeSwitcher) {
      themeSwitcher.addEventListener('click', () => this.toggle());
    }
  }

  showToast(message, type = 'info') {
    const container = document.getElementById('toast-container') || this.createToastContainer();
    
    const toast = document.createElement('div');
    toast.className = `toast ${type}`;
    toast.textContent = message;
    
    container.appendChild(toast);

    setTimeout(() => {
      toast.style.animation = 'slideIn 0.3s ease reverse';
      setTimeout(() => {
        if (toast.parentNode) {
          toast.remove();
        }
      }, 300);
    }, 3000);
  }

  createToastContainer() {
    const container = document.createElement('div');
    container.id = 'toast-container';
    container.className = 'toast-container';
    document.body.appendChild(container);
    return container;
  }
}

// URL Helper Functions
function createStreamingUrl(anime) {
  const baseUrl = window.location.origin;
  let slug = anime.title
    .toLowerCase()
    .replace(/[^a-z0-9\s]/g, '')
    .replace(/\s+/g, '-')
    .replace(/-+/g, '-')
    .replace(/^-|-$/g, '');
  
  return `${baseUrl}/streaming-${slug}`;
}

function parseUrlParams() {
  const urlParams = new URLSearchParams(window.location.search);
  return {
    id: parseInt(urlParams.get('id')),
    ep: parseInt(urlParams.get('ep')) || 1,
    search: urlParams.get('search') || '',
    filter: urlParams.get('filter') || 'all'
  };
}

// JSONBin API Functions
async function getData() {
  try {
    const response = await fetch(`${JSONBIN_URL}/latest`, {
      headers: { "X-Master-Key": JSONBIN_KEY }
    });
    const data = await response.json();
    return data.record || [];
  } catch (error) {
    console.error('Error getting data:', error);
    themeManager.showToast('Failed to load anime data', 'error');
    return [];
  }
}

// Text Truncation Helper
function truncateText(text, maxLength = 100) {
  if (!text) return 'No description available';
  return text.length > maxLength ? text.substring(0, maxLength) + '...' : text;
}

// Main Controller Class
class IndexController {
  constructor() {
    this.animeList = document.getElementById('animeList');
    this.searchInput = document.getElementById('searchInput');
    this.filterSelect = document.getElementById('filterSelect');
    this.sortSelect = document.getElementById('sortSelect');
    this.resetBtn = document.getElementById('resetBtn');
    this.skeletonWrapper = document.getElementById('skeletonWrapper');
    this.loadingIndicator = document.getElementById('loadingIndicator');
    this.resultCount = document.getElementById('resultCount');
    this.noResults = document.getElementById('noResults');
    
    this.currentData = [];
    this.isGridView = true;
    this.isLoading = false;

    if (this.animeList) {
      this.init();
    }
  }

  async init() {
    this.bindEvents();
    this.showLoading();
    
    // Load data from JSONBin
    animeData = await getData();
    this.currentData = [...animeData];
    
    // Apply URL parameters if any
    this.applyUrlParams();
    
    this.updateStats();
    this.hideLoading();
    this.renderAnimeList(this.currentData);
  }

  applyUrlParams() {
    const params = parseUrlParams();
    if (params.search) {
      this.searchInput.value = params.search;
    }
    if (params.filter && params.filter !== 'all') {
      this.filterSelect.value = params.filter;
    }
    if (params.search || params.filter !== 'all') {
      this.filterAndSearch();
    }
  }

  bindEvents() {
    if (this.searchInput) {
      this.searchInput.addEventListener('input', this.debounce(() => {
        this.filterAndSearch();
      }, 300));
    }

    if (this.filterSelect) {
      this.filterSelect.addEventListener('change', () => this.filterAndSearch());
    }

    if (this.sortSelect) {
      this.sortSelect.addEventListener('change', () => this.filterAndSearch());
    }

    if (this.resetBtn) {
      this.resetBtn.addEventListener('click', () => this.resetFilters());
    }

    const gridViewBtn = document.getElementById('gridView');
    const listViewBtn = document.getElementById('listView');
    
    if (gridViewBtn && listViewBtn) {
      gridViewBtn.addEventListener('click', () => this.toggleView('grid'));
      listViewBtn.addEventListener('click', () => this.toggleView('list'));
    }
  }

  showLoading() {
    this.isLoading = true;
    if (this.loadingIndicator) {
      this.loadingIndicator.style.display = 'flex';
    }
    if (this.skeletonWrapper) {
      this.renderSkeleton(6);
    }
    if (this.animeList) {
      this.animeList.style.display = 'none';
    }
  }

  hideLoading() {
    this.isLoading = false;
    if (this.loadingIndicator) {
      this.loadingIndicator.style.display = 'none';
    }
    if (this.skeletonWrapper) {
      this.skeletonWrapper.innerHTML = '';
    }
    if (this.animeList) {
      this.animeList.style.display = 'grid';
    }
  }

  renderSkeleton(count = 6) {
    if (!this.skeletonWrapper) return;
    
    this.skeletonWrapper.innerHTML = '';
    for (let i = 0; i < count; i++) {
      const skeleton = document.createElement('div');
      skeleton.className = 'skeleton';
      this.skeletonWrapper.appendChild(skeleton);
    }
  }

  renderAnimeList(data) {
    if (!this.animeList) return;

    this.animeList.innerHTML = '';
    this.updateResultCount(data.length);

    if (data.length === 0) {
      this.showNoResults();
      return;
    }

    this.hideNoResults();

    data.forEach((anime, index) => {
      const card = this.createAnimeCard(anime);
      card.style.animationDelay = `${index * 0.1}s`;
      this.animeList.appendChild(card);
    });

    this.animeList.className = this.isGridView ? 'anime-grid' : 'anime-grid list-view';
  }

  createAnimeCard(anime) {
    const card = document.createElement('a');
    card.className = 'card';
    
    // Use streaming URL with ID parameter
    const streamingUrl = `${createStreamingUrl(anime)}?id=${anime.id}&ep=1`;
    card.href = streamingUrl;
    
    // Handle click for navigation
    card.addEventListener('click', (e) => {
      e.preventDefault();
      // Store in sessionStorage for fallback
      sessionStorage.setItem('current_anime_id', anime.id);
      sessionStorage.setItem('current_episode', 1);
      window.location.href = streamingUrl;
    });
    
    const statusClass = anime.status.toLowerCase() === 'ongoing' ? 'status-ongoing' : 'status-complete';
    const truncatedTitle = anime.title.length > 50 ? anime.title.substring(0, 50) + '...' : anime.title;
    const episodeCount = anime.episodes ? anime.episodes.length : 0;
    
    card.innerHTML = `
      <div class="card-image">
        <img src="${anime.thumb}" alt="${anime.title}" loading="lazy" onerror="this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjUwIiBoZWlnaHQ9IjI4MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZjNmNGY2Ii8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCwgc2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNHB4IiBmaWxsPSIjOWNhM2FmIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBkeT0iLjNlbSI+Tm8gSW1hZ2U8L3RleHQ+PC9zdmc+'">
        <div class="card-overlay">
          <div class="play-icon">‚ñ∂</div>
        </div>
      </div>
      <div class="card-info">
        <div class="card-title" title="${anime.title}">${truncatedTitle}</div>
        <div class="card-meta">
          <span class="status-badge ${statusClass}">${anime.status}</span>
          ${anime.year ? `<span class="year">${anime.year}</span>` : ''}
        </div>
        <div class="card-details">
          ${anime.rating ? `<div class="rating">‚≠ê ${anime.rating}</div>` : ''}
          ${episodeCount > 0 ? `<div class="episodes">${episodeCount} Episodes</div>` : ''}
        </div>
        ${anime.genre ? `<div class="genre">${anime.genre.length > 30 ? anime.genre.substring(0, 30) + '...' : anime.genre}</div>` : ''}
      </div>
    `;

    return card;
  }

  filterAndSearch() {
    this.showLoading();
    
    setTimeout(() => {
      const query = this.searchInput?.value.toLowerCase() || '';
      const status = this.filterSelect?.value || 'all';
      const sort = this.sortSelect?.value || 'title';

      let filtered = animeData.filter(anime => {
        const matchesSearch = anime.title.toLowerCase().includes(query) ||
                            (anime.genre && anime.genre.toLowerCase().includes(query)) ||
                            (anime.description && anime.description.toLowerCase().includes(query));
        const matchesStatus = status === 'all' || anime.status === status;
        return matchesSearch && matchesStatus;
      });

      filtered = this.sortData(filtered, sort);

      this.currentData = filtered;
      this.hideLoading();
      this.renderAnimeList(filtered);
    }, 300);
  }

  sortData(data, sortBy) {
    switch (sortBy) {
      case 'title':
        return data.sort((a, b) => a.title.localeCompare(b.title));
      case 'status':
        return data.sort((a, b) => a.status.localeCompare(b.status));
      case 'year':
        return data.sort((a, b) => (b.year || 0) - (a.year || 0));
      case 'rating':
        return data.sort((a, b) => (b.rating || 0) - (a.rating || 0));
      default:
        return data;
    }
  }

  resetFilters() {
    if (this.searchInput) this.searchInput.value = '';
    if (this.filterSelect) this.filterSelect.value = 'all';
    if (this.sortSelect) this.sortSelect.value = 'title';
    
    this.currentData = [...animeData];
    this.renderAnimeList(this.currentData);
    
    themeManager.showToast('Filters reset', 'success');
  }

  toggleView(viewType) {
    this.isGridView = viewType === 'grid';
    
    const gridBtn = document.getElementById('gridView');
    const listBtn = document.getElementById('listView');
    
    if (gridBtn && listBtn) {
      gridBtn.classList.toggle('active', this.isGridView);
      listBtn.classList.toggle('active', !this.isGridView);
    }
    
    this.renderAnimeList(this.currentData);
  }

  updateResultCount(count) {
    if (this.resultCount) {
      this.resultCount.textContent = count;
    }
  }

  showNoResults() {
    if (this.noResults) {
      this.noResults.style.display = 'block';
    }
  }

  hideNoResults() {
    if (this.noResults) {
      this.noResults.style.display = 'none';
    }
  }

  updateStats() {
    const animeCountEl = document.getElementById('animeCount');
    if (animeCountEl) {
      this.countUp(animeCountEl, animeData.length, 1500);
    }
  }

  countUp(element, target, duration = 1500) {
    const start = 0;
    const increment = target / (duration / 16);
    let current = start;

    const timer = setInterval(() => {
      current += increment;
      element.textContent = Math.floor(current);
      
      if (current >= target) {
        element.textContent = target;
        clearInterval(timer);
      }
    }, 16);
  }

  debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }
}

// Global reset function for no results button
function resetFilters() {
  if (indexController) {
    indexController.resetFilters();
  }
}

// Initialize Application
let themeManager;
let indexController;

// Handle browser back/forward navigation
window.addEventListener('popstate', (event) => {
  const params = parseUrlParams();
  if (params.id && !isNaN(params.id)) {
    const streamingUrl = `/streaming-${params.id}?id=${params.id}`;
    window.location.href = streamingUrl;
  }
});

document.addEventListener('DOMContentLoaded', () => {
  // Initialize theme manager
  themeManager = new ThemeManager();
  
  // Initialize main controller
  indexController = new IndexController();
});

// Service Worker for offline functionality
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/sw.js')
      .then((registration) => {
        console.log('SW registered: ', registration);
      })
      .catch((registrationError) => {
        console.log('SW registration failed: ', registrationError);
      });
  });
}
</script>
</body>
</html><div class="stat-label">Anime Series</div>
      </div>
      <div class="stat-item">
        <div class="stat-number">HD</div>
        <div class="stat-label">Quality</div>
      </div>
      <div class="stat-item">
        <div class="stat-number">24/7</div>
        <div class="stat-label">Available</div>
      </div>
    </div>
  </div>
</section>

<div class="container">
  <!-- Search Section -->
  <section class="search-section">
    <div class="search-header">
      <h2 class="section-title">Explore Anime</h2>
      <div class="view-controls">
        <button id="gridView" class="view-btn active" title="Grid View">‚äû</button>
        <button id="listView" class="view-btn" title="List View">‚ò∞</button>
      </div>
    </div>
    
    <div class="search-wrapper">
      <div class="search-box">
        <input type="text" id="searchInput" placeholder="Search anime...">
        <span class="search-icon">üîç</span>
      </div>
      
      <select id="filterSelect" class="filter-select">
        <option value="all">All Status</option>
        <option value="Ongoing">Ongoing</option>
        <option value="Complete">Complete</option>
      </select>
      
      <select id="sortSelect" class="sort-select">
        <option value="title">Sort by Title</option>
        <option value="status">Sort by Status</option>
        <option value="year">Sort by Year</option>
        <option value="rating">Sort by Rating</option>
      </select>
      
      <button id="resetBtn" class="reset-btn">Reset</button>
    </div>
  </section>

  <!-- Results Info -->
  <div class="results-info">
    <span id="resultCount">0</span> anime found
    <div id="loadingIndicator" class="loading-indicator" style="display:none;">
      <div class="spinner"></div>
      Loading...
    </div>
  </div>

  <!-- Anime Grid -->
  <div id="animeList" class="anime-grid"></div>

  <!-- Skeleton Loading -->
  <div id="skeletonWrapper" class="skeleton-grid"></div>

  <!-- No Results -->
  <div id="noResults" class="no-results" style="display:none;">
    <div class="no-results-icon">üòû</div>
    <h3>No anime found</h3>
    <p>Try different search terms</p>
  </div>
</div>

<!-- Footer -->
<footer class="footer">
  <div class="footer-content">
    <p>&copy; 2025 DongTube - Premium Anime Streaming</p>
    <div class="footer-links">
      <a href="#" class="footer-link">About</a>
      <a href="#" class="footer-link">Contact</a>
      <a href="#" class="footer-link">Privacy</a>
      <a href="admin.html" class="footer-link">Admin</a>
    </div>
  </div>
</footer>

<!-- Toast Container -->
<div id="toast-container" class="toast-container"></div>

<script>
// JSONBin Configuration
const JSONBIN_URL = "https://api.jsonbin.io/v3/b/68c7fdc9d0ea881f407e85cc";
const JSONBIN_KEY = "$2a$10$PsVzgljojE5fq8qZRmpE4uzMr0K9LArqfmumGVSmNY.P8F2iTKrim";

// Global variables
let animeData = [];
let currentData = [];
let isGridView = true;
let isLoading = false;

// Theme Management
class ThemeManager {
  constructor() {
    this.currentTheme = localStorage.getItem('dongtube_theme') || 'dark';
    this.init();
  }

  init() {
    this.applyTheme(this.currentTheme);
    this.bindEvents();
  }

  applyTheme(theme) {
    document.documentElement.setAttribute('data-theme', theme);
    const themeIcon = document.querySelector('#themeSwitcher');
    if (themeIcon) {
      themeIcon.textContent = theme === 'dark' ? 'üåô' : '‚òÄÔ∏è';
    }
    this.currentTheme = theme;
    localStorage.setItem('dongtube_theme', theme);
  }

  toggle() {
    const newTheme = this.currentTheme === 'dark' ? 'light' : 'dark';
    this.applyTheme(newTheme);
    this.showToast(`Switched to ${newTheme} theme`, 'success');
  }

  bindEvents() {
    const themeSwitcher = document.getElementById('themeSwitcher');
    if (themeSwitcher) {
      themeSwitcher.addEventListener('click', () => this.toggle());
    }
  }

  showToast(message, type = 'info') {
    const container = document.getElementById('toast-container') || this.createToastContainer();
    
    const toast = document.createElement('div');
    toast.className = `toast ${type}`;
    toast.textContent = message;
    
    container.appendChild(toast);

    setTimeout(() => {
      toast.style.animation = 'slideIn 0.3s ease reverse';
      setTimeout(() => {
        if (toast.parentNode) {
          toast.remove();
        }
      }, 300);
    }, 3000);
  }

  createToastContainer() {
    const container = document.createElement('div');
    container.id = 'toast-container';
    container.className = 'toast-container';
    document.body.appendChild(container);
    return container;
  }
}

// URL Helper Functions
function createSEOUrl(anime, episode = null) {
  const baseUrl = window.location.origin;
  let slug = anime.title
    .toLowerCase()
    .replace(/[^a-z0-9\s]/g, '')
    .replace(/\s+/g, '-')
    .replace(/-+/g, '-')
    .replace(/^-|-$/g, '');
  
  if (episode) {
    const episodeSlug = episode.title
      ? episode.title.toLowerCase().replace(/[^a-z0-9\s]/g, '').replace(/\s+/g, '-')
      : `episode-${episode.num}`;
    return `${baseUrl}/streaming/${slug}/${episodeSlug}?id=${anime.id}&ep=${episode.num}`;
  }
  
  return `${baseUrl}/anime/${slug}?id=${anime.id}`;
}

function parseUrlParams() {
  const urlParams = new URLSearchParams(window.location.search);
  return {
    id: parseInt(urlParams.get('id')),
    ep: parseInt(urlParams.get('ep')) || 1
  };
}

// JSONBin API Functions
async function getData() {
  try {
    const response = await fetch(`${JSONBIN_URL}/latest`, {
      headers: { "X-Master-Key": JSONBIN_KEY }
    });
    const data = await response.json();
    return data.record || [];
  } catch (error) {
    console.error('Error getting data:', error);
    themeManager.showToast('Failed to load anime data', 'error');
    return [];
  }
}

// Main Controller Class
class IndexController {
  constructor() {
    this.animeList = document.getElementById('animeList');
    this.searchInput = document.getElementById('searchInput');
    this.filterSelect = document.getElementById('filterSelect');
    this.sortSelect = document.getElementById('sortSelect');
    this.resetBtn = document.getElementById('resetBtn');
    this.skeletonWrapper = document.getElementById('skeletonWrapper');
    this.loadingIndicator = document.getElementById('loadingIndicator');
    this.resultCount = document.getElementById('resultCount');
    this.noResults = document.getElementById('noResults');
    
    this.currentData = [];
    this.isGridView = true;
    this.isLoading = false;

    if (this.animeList) {
      this.init();
    }
  }

  async init() {
    this.bindEvents();
    this.showLoading();
    
    // Load data from JSONBin
    animeData = await getData();
    this.currentData = [...animeData];
    
    this.updateStats();
    this.hideLoading();
    this.renderAnimeList(this.currentData);
  }

  bindEvents() {
    if (this.searchInput) {
      this.searchInput.addEventListener('input', this.debounce(() => {
        this.filterAndSearch();
      }, 300));
    }

    if (this.filterSelect) {
      this.filterSelect.addEventListener('change', () => this.filterAndSearch());
    }

    if (this.sortSelect) {
      this.sortSelect.addEventListener('change', () => this.filterAndSearch());
    }

    if (this.resetBtn) {
      this.resetBtn.addEventListener('click', () => this.resetFilters());
    }

    const gridViewBtn = document.getElementById('gridView');
    const listViewBtn = document.getElementById('listView');
    
    if (gridViewBtn && listViewBtn) {
      gridViewBtn.addEventListener('click', () => this.toggleView('grid'));
      listViewBtn.addEventListener('click', () => this.toggleView('list'));
    }
  }

  showLoading() {
    this.isLoading = true;
    if (this.loadingIndicator) {
      this.loadingIndicator.style.display = 'flex';
    }
    if (this.skeletonWrapper) {
      this.renderSkeleton(6);
    }
    if (this.animeList) {
      this.animeList.style.display = 'none';
    }
  }

  hideLoading() {
    this.isLoading = false;
    if (this.loadingIndicator) {
      this.loadingIndicator.style.display = 'none';
    }
    if (this.skeletonWrapper) {
      this.skeletonWrapper.innerHTML = '';
    }
    if (this.animeList) {
      this.animeList.style.display = 'grid';
    }
  }

  renderSkeleton(count = 6) {
    if (!this.skeletonWrapper) return;
    
    this.skeletonWrapper.innerHTML = '';
    for (let i = 0; i < count; i++) {
      const skeleton = document.createElement('div');
      skeleton.className = 'skeleton';
      this.skeletonWrapper.appendChild(skeleton);
    }
  }

  renderAnimeList(data) {
    if (!this.animeList) return;

    this.animeList.innerHTML = '';
    this.updateResultCount(data.length);

    if (data.length === 0) {
      this.showNoResults();
      return;
    }

    this.hideNoResults();

    data.forEach((anime, index) => {
      const card = this.createAnimeCard(anime);
      card.style.animationDelay = `${index * 0.1}s`;
      this.animeList.appendChild(card);
    });

    this.animeList.className = this.isGridView ? 'anime-grid' : 'anime-grid list-view';
  }

  createAnimeCard(anime) {
    const card = document.createElement('a');
    card.className = 'card';
    
    // Use SEO-friendly URL
    const seoUrl = createSEOUrl(anime);
    card.href = seoUrl;
    
    // Handle click for client-side routing
    card.addEventListener('click', (e) => {
      e.preventDefault();
      // Update URL without page refresh
      history.pushState({}, '', seoUrl);
      // Navigate to watch page
      this.navigateToWatchPage(anime.id, 1);
    });
    
    const statusClass = anime.status.toLowerCase() === 'ongoing' ? 'status-ongoing' : 'status-complete';
    
    card.innerHTML = `
      <img src="${anime.thumb}" alt="${anime.title}" loading="lazy" onerror="this.src='data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAwIiBoZWlnaHQ9IjI4MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjZjNmNGY2Ii8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCwgc2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNHB4IiBmaWxsPSIjOWNhM2FmIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBkeT0iLjNlbSI+Tm8gSW1hZ2U8L3RleHQ+PC9zdmc+'">
      <div class="info">
        <div class="title">${anime.title}</div>
        <div class="status">
          <span class="status-badge ${statusClass}">${anime.status}</span>
          ${anime.year ? `<span class="year">${anime.year}</span>` : ''}
          ${anime.rating ? `<span class="rating">‚≠ê ${anime.rating}</span>` : ''}
        </div>
        ${anime.episodes && anime.episodes.length > 0 ? `<div class="episodes">Episodes: ${anime.episodes.length}</div>` : ''}
      </div>
    `;

    return card;
  }

  navigateToWatchPage(animeId, episodeNum = 1) {
    // Store anime data in sessionStorage for the watch page
    sessionStorage.setItem('current_anime_id', animeId);
    sessionStorage.setItem('current_episode', episodeNum);
    
    // Create watch page URL
    const anime = animeData.find(a => a.id === animeId);
    if (anime && anime.episodes && anime.episodes.length > 0) {
      const episode = anime.episodes[episodeNum - 1];
      const watchUrl = createSEOUrl(anime, episode);
      window.location.href = watchUrl.replace('/streaming/', '/watch.html?');
    }
  }

  filterAndSearch() {
    this.showLoading();
    
    setTimeout(() => {
      const query = this.searchInput?.value.toLowerCase() || '';
      const status = this.filterSelect?.value || 'all';
      const sort = this.sortSelect?.value || 'title';

      let filtered = animeData.filter(anime => {
        const matchesSearch = anime.title.toLowerCase().includes(query) ||
                            (anime.genre && anime.genre.toLowerCase().includes(query)) ||
                            (anime.description && anime.description.toLowerCase().includes(query));
        const matchesStatus = status === 'all' || anime.status === status;
        return matchesSearch && matchesStatus;
      });

      filtered = this.sortData(filtered, sort);

      this.currentData = filtered;
      this.hideLoading();
      this.renderAnimeList(filtered);
    }, 300);
  }

  sortData(data, sortBy) {
    switch (sortBy) {
      case 'title':
        return data.sort((a, b) => a.title.localeCompare(b.title));
      case 'status':
        return data.sort((a, b) => a.status.localeCompare(b.status));
      case 'year':
        return data.sort((a, b) => (b.year || 0) - (a.year || 0));
      case 'rating':
        return data.sort((a, b) => (b.rating || 0) - (a.rating || 0));
      default:
        return data;
    }
  }

  resetFilters() {
    if (this.searchInput) this.searchInput.value = '';
    if (this.filterSelect) this.filterSelect.value = 'all';
    if (this.sortSelect) this.sortSelect.value = 'title';
    
    this.currentData = [...animeData];
    this.renderAnimeList(this.currentData);
    
    themeManager.showToast('Filters reset', 'success');
  }

  toggleView(viewType) {
    this.isGridView = viewType === 'grid';
    
    const gridBtn = document.getElementById('gridView');
    const listBtn = document.getElementById('listView');
    
    if (gridBtn && listBtn) {
      gridBtn.classList.toggle('active', this.isGridView);
      listBtn.classList.toggle('active', !this.isGridView);
    }
    
    this.renderAnimeList(this.currentData);
  }

  updateResultCount(count) {
    if (this.resultCount) {
      this.resultCount.textContent = count;
    }
  }

  showNoResults() {
    if (this.noResults) {
      this.noResults.style.display = 'block';
    }
  }

  hideNoResults() {
    if (this.noResults) {
      this.noResults.style.display = 'none';
    }
  }

  updateStats() {
    const animeCountEl = document.getElementById('animeCount');
    if (animeCountEl) {
      this.countUp(animeCountEl, animeData.length, 1500);
    }
  }

  countUp(element, target, duration = 1500) {
    const start = 0;
    const increment = target / (duration / 16);
    let current = start;

    const timer = setInterval(() => {
      current += increment;
      element.textContent = Math.floor(current);
      
      if (current >= target) {
        element.textContent = target;
        clearInterval(timer);
      }
    }, 16);
  }

  debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }
}

// Initialize Application
let themeManager;
let indexController;

// Handle browser back/forward navigation
window.addEventListener('popstate', (event) => {
  const params = parseUrlParams();
  if (params.id && !isNaN(params.id)) {
    indexController.navigateToWatchPage(params.id, params.ep || 1);
  }
});

document.addEventListener('DOMContentLoaded', () => {
  // Initialize theme manager
  themeManager = new ThemeManager();
  
  // Initialize main controller
  indexController = new IndexController();
});

// Service Worker for offline functionality (optional)
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/sw.js')
      .then((registration) => {
        console.log('SW registered: ', registration);
      })
      .catch((registrationError) => {
        console.log('SW registration failed: ', registrationError);
      });
  });
}
</script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Admin Dashboard - DongTube</title>
<link rel="icon" type="image/png" href="https://b.top4top.io/p_35449hn0x0.jpg">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&display=swap" rel="stylesheet">
<meta name="robots" content="noindex, nofollow">

<style>
:root {
  /* Dark theme with yellow accent */
  --bg: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 30%, #2a2a2a 60%, #3a3a3a 100%);
  --bg-secondary: rgba(15, 15, 15, 0.95);
  --card: rgba(25, 25, 25, 0.9);
  --card-hover: rgba(30, 30, 30, 0.95);
  --card-border: rgba(255, 255, 255, 0.08);
  --accent: #ffd700;
  --accent2: #ffb000;
  --accent-glow: rgba(255, 215, 0, 0.4);
  --text: #ffffff;
  --text-secondary: #b0b0b0;
  --text-muted: #808080;
  --success: #10b981;
  --warning: #f59e0b;
  --error: #ef4444;
  --info: #3b82f6;
  --radius: 16px;
  --radius-sm: 12px;
  --radius-xs: 8px;
  --transition: all 0.35s cubic-bezier(0.4, 0, 0.2, 1);
  --shadow: 0 8px 25px rgba(0, 0, 0, 0.6);
  --shadow-lg: 0 16px 40px rgba(0, 0, 0, 0.8);
  --glow: 0 0 30px var(--accent-glow);
  --backdrop-blur: blur(20px);
  --glass-border: rgba(255, 255, 255, 0.12);
  --glass-bg: rgba(255, 255, 255, 0.05);

  /* Legacy compatibility variables */
  --primary: var(--accent);
  --primary-dark: var(--accent2);
  --primary-light: var(--accent);
  --secondary: var(--accent2);
  --bg-primary: #0a0a0a;
  --bg-tertiary: #3a3a3a;
  --surface: var(--card);
  --surface-elevated: var(--card-hover);
  --surface-glass: var(--glass-bg);
  --border: var(--card-border);
  --border-hover: var(--glass-border);
  --text-primary: var(--text);
  --text-tertiary: var(--text-secondary);
  --glow-primary: var(--glow);
  --gradient-primary: linear-gradient(135deg, var(--accent), var(--accent2));
  --gradient-hero: var(--bg);
  --gradient-card: linear-gradient(135deg, var(--accent-glow), transparent);
  --blur-sm: blur(4px);
  --blur-md: blur(8px);
  --blur-lg: blur(12px);
  --blur-xl: blur(20px);
  --transition-fast: 0.15s ease-in-out;
  --transition-normal: var(--transition);
  --transition-slow: 0.5s cubic-bezier(0.4, 0, 0.2, 1);
  --radius-md: var(--radius-sm);
  --radius-lg: var(--radius);
  --radius-xl: 20px;
  --radius-full: 9999px;
  --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.3);
  --shadow-md: var(--shadow);
  --shadow-xl: var(--shadow-lg);
}

[data-theme="light"] {
  --bg: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 30%, #dee2e6 60%, #ced4da 100%);
  --bg-secondary: rgba(248, 249, 250, 0.95);
  --card: rgba(255, 255, 255, 0.9);
  --card-hover: rgba(255, 255, 255, 0.98);
  --card-border: rgba(0, 0, 0, 0.08);
  --text: #212529;
  --text-secondary: #495057;
  --text-muted: #6c757d;
  --glass-border: rgba(0, 0, 0, 0.08);
  --glass-bg: rgba(0, 0, 0, 0.03);
  --shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
  --shadow-lg: 0 16px 40px rgba(0, 0, 0, 0.2);

  /* Legacy compatibility for light theme */
  --bg-primary: #f8f9fa;
  --bg-tertiary: #ced4da;
  --surface: var(--card);
  --surface-elevated: var(--card-hover);
  --surface-glass: var(--glass-bg);
  --border: var(--card-border);
  --border-hover: var(--glass-border);
  --text-primary: var(--text);
  --text-tertiary: var(--text-secondary);
  --gradient-hero: var(--bg);
}

/* Global Reset & Base */
*, *::before, *::after {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

html {
  scroll-behavior: smooth;
  font-size: 16px;
  overflow-x: hidden;
}

body {
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
  background: var(--gradient-hero);
  background-attachment: fixed;
  color: var(--text-primary);
  line-height: 1.6;
  min-height: 100vh;
  font-feature-settings: 'cv02', 'cv03', 'cv04', 'cv11';
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-rendering: optimizeLegibility;
}

/* Enhanced Background Animation */
.bg-animation {
  position: fixed;
  inset: 0;
  z-index: -1;
  overflow: hidden;
  pointer-events: none;
}

.floating-orb {
  position: absolute;
  border-radius: 50%;
  filter: blur(2px);
  opacity: 0.4;
  animation: float 25s infinite ease-in-out;
}

.orb-1 {
  width: 250px;
  height: 250px;
  background: radial-gradient(circle, var(--primary), transparent 70%);
  top: 15%;
  left: 15%;
  animation-delay: 0s;
}

.orb-2 {
  width: 180px;
  height: 180px;
  background: radial-gradient(circle, var(--secondary), transparent 70%);
  top: 65%;
  right: 25%;
  animation-delay: -12s;
}

.orb-3 {
  width: 140px;
  height: 140px;
  background: radial-gradient(circle, var(--accent), transparent 70%);
  bottom: 30%;
  left: 60%;
  animation-delay: -8s;
}

@keyframes float {
  0%, 100% { transform: translateY(0) rotate(0deg) scale(1); }
  25% { transform: translateY(-30px) rotate(90deg) scale(1.1); }
  50% { transform: translateY(20px) rotate(180deg) scale(0.9); }
  75% { transform: translateY(-40px) rotate(270deg) scale(1.05); }
}

/* Shake animation for login form */
@keyframes shake {
  0%, 100% { transform: translateX(0); }
  10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
  20%, 40%, 60%, 80% { transform: translateX(5px); }
}

/* Login Modal */
.login-modal {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.8);
  backdrop-filter: var(--blur-lg);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 2000;
  padding: 2rem;
}

.login-form {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius-xl);
  padding: 3rem;
  box-shadow: var(--shadow-xl);
  backdrop-filter: var(--blur-lg);
  max-width: 400px;
  width: 100%;
  position: relative;
  overflow: hidden;
  animation: modalSlideIn 0.4s ease forwards;
}

@keyframes modalSlideIn {
  from {
    opacity: 0;
    transform: scale(0.9) translateY(-50px);
  }
  to {
    opacity: 1;
    transform: scale(1) translateY(0);
  }
}

.login-form::before {
  content: '';
  position: absolute;
  inset: 0;
  background: var(--gradient-card);
  opacity: 0.3;
  z-index: -1;
}

.login-form h2 {
  text-align: center;
  font-size: 2rem;
  font-weight: 800;
  background: var(--gradient-primary);
  -webkit-background-clip: text;
  background-clip: text;
  -webkit-text-fill-color: transparent;
  margin-bottom: 2rem;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.5rem;
}

.form-group {
  margin-bottom: 1.5rem;
}

.form-group label {
  display: block;
  margin-bottom: 0.75rem;
  font-weight: 600;
  color: var(--text-primary);
  font-size: 0.95rem;
}

.form-group input,
.form-group textarea,
.form-group select {
  width: 100%;
  padding: 1rem 1.25rem;
  background: var(--surface-elevated);
  border: 2px solid var(--border);
  border-radius: var(--radius-lg);
  color: var(--text-primary);
  font-size: 1rem;
  font-weight: 500;
  outline: none;
  transition: var(--transition-normal);
  backdrop-filter: var(--blur-md);
}

.form-group input:focus,
.form-group textarea:focus,
.form-group select:focus {
  border-color: var(--primary);
  box-shadow: 0 0 0 3px rgba(0, 212, 255, 0.1), var(--glow-primary);
  transform: translateY(-2px);
}

.form-group input::placeholder,
.form-group textarea::placeholder {
  color: var(--text-muted);
}

.form-group textarea {
  resize: vertical;
  min-height: 120px;
}

.login-btn {
  width: 100%;
  padding: 1rem 2rem;
  background: var(--gradient-primary);
  border: none;
  border-radius: var(--radius-lg);
  color: white;
  font-size: 1rem;
  font-weight: 600;
  cursor: pointer;
  transition: var(--transition-normal);
  position: relative;
  overflow: hidden;
  box-shadow: var(--shadow-md);
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.5rem;
}

.login-btn::before {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(135deg, var(--primary-dark), var(--secondary));
  opacity: 0;
  transition: var(--transition-normal);
}

.login-btn:hover::before {
  opacity: 1;
}

.login-btn:hover {
  transform: translateY(-3px);
  box-shadow: var(--shadow-lg), var(--glow-primary);
}

.login-btn:disabled {
  opacity: 0.7;
  cursor: not-allowed;
  transform: none !important;
}

.login-btn span {
  position: relative;
  z-index: 1;
}

/* Main Container */
.main-container {
  max-width: 1400px;
  margin: 0 auto;
  background: var(--surface);
  border-radius: var(--radius-xl);
  overflow: hidden;
  box-shadow: var(--shadow-xl);
  border: 1px solid var(--border);
  backdrop-filter: var(--blur-lg);
  position: relative;
}

.main-container::before {
  content: '';
  position: absolute;
  inset: 0;
  background: var(--gradient-card);
  opacity: 0.2;
  z-index: -1;
}

/* Header */
.header {
  background: var(--gradient-primary);
  color: white;
  padding: 3rem;
  text-align: center;
  position: relative;
  overflow: hidden;
}

.header::before {
  content: '';
  position: absolute;
  inset: 0;
  background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><defs><pattern id="grid" width="10" height="10" patternUnits="userSpaceOnUse"><path d="M 10 0 L 0 0 0 10" fill="none" stroke="rgba(255,255,255,0.1)" stroke-width="0.5"/></pattern></defs><rect width="100%" height="100%" fill="url(%23grid)"/></svg>');
  opacity: 0.3;
}

.header h1 {
  font-size: 2.5rem;
  font-weight: 900;
  margin-bottom: 0.75rem;
  text-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
  position: relative;
  z-index: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.75rem;
}

.header p {
  font-size: 1.125rem;
  opacity: 0.9;
  position: relative;
  z-index: 1;
}

.logout-btn {
  position: absolute;
  top: 2rem;
  right: 2rem;
  background: rgba(239, 68, 68, 0.9);
  color: white;
  border: none;
  padding: 0.75rem 1.5rem;
  border-radius: var(--radius-lg);
  font-weight: 600;
  cursor: pointer;
  transition: var(--transition-normal);
  backdrop-filter: var(--blur-md);
  z-index: 10;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.logout-btn:hover {
  background: var(--error);
  transform: translateY(-2px);
  box-shadow: var(--shadow-md);
}

/* Content */
.content {
  padding: 3rem;
}

/* Statistics Grid */
.stats-container {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 2rem;
  margin-bottom: 3rem;
}

.stat-card {
  background: var(--gradient-primary);
  color: white;
  padding: 2.5rem;
  border-radius: var(--radius-xl);
  text-align: center;
  box-shadow: var(--shadow-lg);
  position: relative;
  overflow: hidden;
  transition: var(--transition-slow);
}

.stat-card::before {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), transparent);
  z-index: 1;
  pointer-events: none;
}

.stat-card:hover {
  transform: translateY(-8px) scale(1.02);
  box-shadow: var(--shadow-xl), var(--glow-primary);
}

.stat-card h3 {
  position: relative;
  z-index: 2;
  font-size: 3rem;
  font-weight: 900;
  margin-bottom: 0.75rem;
  text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
}

.stat-card p {
  position: relative;
  z-index: 2;
  font-size: 1.125rem;
  font-weight: 600;
  opacity: 0.9;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

/* Enhanced Tabs */
.tabs {
  display: flex;
  background: var(--surface-elevated);
  border-radius: var(--radius-lg);
  margin-bottom: 3rem;
  overflow: hidden;
  border: 1px solid var(--border);
  backdrop-filter: var(--blur-md);
}

.tab {
  flex: 1;
  padding: 1.25rem 2rem;
  text-align: center;
  cursor: pointer;
  transition: var(--transition-normal);
  border: none;
  background: transparent;
  font-size: 1rem;
  font-weight: 600;
  color: var(--text-secondary);
  position: relative;
  overflow: hidden;
}

.tab::before {
  content: '';
  position: absolute;
  inset: 0;
  background: var(--gradient-primary);
  opacity: 0;
  transition: var(--transition-normal);
}

.tab.active::before {
  opacity: 1;
}

.tab.active {
  color: white;
  box-shadow: var(--glow-primary);
}

.tab:hover:not(.active) {
  background: var(--surface-glass);
  color: var(--text-primary);
}

.tab span {
  position: relative;
  z-index: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.5rem;
}

/* Tab Content */
.tab-content {
  display: none;
}

.tab-content.active {
  display: block;
  animation: fadeIn 0.4s ease;
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

/* Enhanced Button System */
.btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 0.5rem;
  padding: 1rem 2rem;
  background: var(--gradient-primary);
  color: white;
  border: none;
  border-radius: var(--radius-lg);
  font-size: 1rem;
  font-weight: 600;
  text-decoration: none;
  cursor: pointer;
  transition: var(--transition-normal);
  box-shadow: var(--shadow-md);
  position: relative;
  overflow: hidden;
}

.btn::before {
  content: '';
  position: absolute;
  inset: 0;
  background: linear-gradient(135deg, var(--primary-dark), var(--secondary));
  opacity: 0;
  transition: var(--transition-normal);
}

.btn:hover::before {
  opacity: 1;
}

.btn:hover {
  transform: translateY(-3px);
  box-shadow: var(--shadow-lg), var(--glow-primary);
}

.btn:disabled {
  opacity: 0.7;
  cursor: not-allowed;
  transform: none !important;
}

.btn span {
  position: relative;
  z-index: 1;
}

.btn-danger {
  background: linear-gradient(135deg, var(--error), #dc2626);
}

.btn-danger:hover {
  box-shadow: var(--shadow-lg), 0 0 30px rgba(239, 68, 68, 0.4);
}

.btn-success {
  background: linear-gradient(135deg, var(--success), #059669);
}

.btn-success:hover {
  box-shadow: var(--shadow-lg), 0 0 30px rgba(16, 185, 129, 0.4);
}

/* Enhanced Search and Filter */
.search-filter {
  background: var(--surface-elevated);
  padding: 2rem;
  border-radius: var(--radius-xl);
  margin-bottom: 3rem;
  border: 1px solid var(--border);
  backdrop-filter: var(--blur-lg);
}

.filter-grid {
  display: grid;
  grid-template-columns: 2fr 1fr 1fr auto;
  gap: 1rem;
  align-items: end;
}

/* Enhanced Anime List */
.anime-list {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
  gap: 2rem;
}

.anime-card {
  background: var(--surface-elevated);
  border: 2px solid var(--border);
  border-radius: var(--radius-xl);
  padding: 2rem;
  transition: var(--transition-slow);
  backdrop-filter: var(--blur-lg);
  position: relative;
  overflow: hidden;
}

.anime-card::before {
  content: '';
  position: absolute;
  inset: 0;
  background: var(--gradient-card);
  opacity: 0;
  transition: var(--transition-slow);
  z-index: -1;
}

.anime-card:hover::before {
  opacity: 0.5;
}

.anime-card:hover {
  border-color: var(--primary);
  transform: translateY(-8px) scale(1.02);
  box-shadow: var(--shadow-xl), var(--glow-primary);
}

.anime-card h3 {
  color: var(--primary);
  font-size: 1.5rem;
  font-weight: 700;
  margin-bottom: 1rem;
  line-height: 1.3;
}

.anime-meta {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1rem;
  font-size: 0.9rem;
  color: var(--text-tertiary);
}

.anime-description {
  margin: 1rem 0;
  line-height: 1.6;
  color: var(--text-secondary);
}

.episodes-count {
  background: var(--gradient-primary);
  color: white;
  padding: 0.4rem 0.8rem;
  border-radius: var(--radius-full);
  font-size: 0.8rem;
  font-weight: 600;
  display: inline-block;
  box-shadow: var(--glow-primary);
}

.status-badge {
  padding: 0.4rem 0.8rem;
  border-radius: var(--radius-full);
  font-size: 0.75rem;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.05em;
  border: 1px solid;
}

.status-ongoing {
  background: rgba(16, 185, 129, 0.15);
  color: var(--success);
  border-color: var(--success);
  box-shadow: 0 0 15px rgba(16, 185, 129, 0.3);
}

.status-complete {
  background: rgba(0, 212, 255, 0.15);
  color: var(--primary);
  border-color: var(--primary);
  box-shadow: 0 0 15px rgba(0, 212, 255, 0.3);
}

/* Loading States */
.loading {
  text-align: center;
  padding: 3rem 2rem;
  color: var(--text-secondary);
}

.loading-spinner {
  width: 40px;
  height: 40px;
  border: 3px solid var(--border);
  border-top: 3px solid var(--primary);
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin: 0 auto 1rem;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* Toast Notifications */
.toast-container {
  position: fixed;
  top: 2rem;
  right: 2rem;
  z-index: 3000;
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.toast {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius-lg);
  padding: 1rem 1.5rem;
  color: var(--text-primary);
  box-shadow: var(--shadow-lg);
  backdrop-filter: var(--blur-lg);
  transform: translateX(400px);
  opacity: 0;
  animation: slideIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
  max-width: 350px;
  font-weight: 500;
  position: relative;
  overflow: hidden;
}

.toast::before {
  content: '';
  position: absolute;
  left: 0;
  top: 0;
  bottom: 0;
  width: 4px;
  background: var(--info);
}

.toast.success::before {
  background: var(--success);
}

.toast.error::before {
  background: var(--error);
}

.toast.warning::before {
  background: var(--warning);
}

.toast.success {
  box-shadow: var(--shadow-lg), 0 0 20px rgba(16, 185, 129, 0.2);
}

.toast.error {
  box-shadow: var(--shadow-lg), 0 0 20px rgba(239, 68, 68, 0.2);
}

.toast.warning {
  box-shadow: var(--shadow-lg), 0 0 20px rgba(245, 158, 11, 0.2);
}

@keyframes slideIn {
  0% {
    transform: translateX(400px);
    opacity: 0;
  }
  100% {
    transform: translateX(0);
    opacity: 1;
  }
}

/* Episode Management */
.episode-form {
  background: var(--surface-elevated);
  padding: 2rem;
  border-radius: var(--radius-lg);
  margin-top: 2rem;
  border: 1px solid var(--border);
  backdrop-filter: var(--blur-md);
}

.episode-form h3 {
  color: var(--primary);
  font-size: 1.25rem;
  font-weight: 700;
  margin-bottom: 1.5rem;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.episode-list {
  margin-top: 1.5rem;
  max-height: 300px;
  overflow-y: auto;
}

.episode-item {
  background: var(--surface);
  padding: 1rem 1.25rem;
  margin-bottom: 1rem;
  border-radius: var(--radius-md);
  border-left: 4px solid var(--primary);
  display: flex;
  justify-content: space-between;
  align-items: center;
  transition: var(--transition-normal);
}

.episode-item:hover {
  background: var(--surface-glass);
  transform: translateX(4px);
}

/* Responsive Design */
@media (max-width: 1200px) {
  .anime-list {
    grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
    gap: 1.5rem;
  }
}

@media (max-width: 968px) {
  .main-container {
    margin: 1rem;
    border-radius: var(--radius-lg);
  }
  
  .content {
    padding: 2rem;
  }
  
  .stats-container {
    grid-template-columns: repeat(2, 1fr);
    gap: 1.5rem;
  }
  
  .filter-grid {
    grid-template-columns: 1fr;
    gap: 1rem;
  }
  
  .tabs {
    flex-wrap: wrap;
  }
  
  .tab {
    flex: none;
    min-width: 150px;
  }
}

@media (max-width: 768px) {
  .header {
    padding: 2rem;
    text-align: center;
  }
  
  .header h1 {
    font-size: 2rem;
  }
  
  .logout-btn {
    position: static;
    margin-top: 1rem;
  }
  
  .content {
    padding: 1.5rem;
  }
  
  .stats-container {
    grid-template-columns: 1fr;
    gap: 1rem;
  }
  
  .stat-card {
    padding: 2rem 1.5rem;
  }
  
  .anime-list {
    grid-template-columns: 1fr;
    gap: 1rem;
  }
  
  .anime-card {
    padding: 1.5rem;
  }
  
  .login-form {
    padding: 2rem;
    margin: 1rem;
  }
  
  .toast-container {
    right: 1rem;
    left: 1rem;
    top: 1rem;
  }
  
  .toast {
    max-width: none;
  }
}

@media (max-width: 480px) {
  .tab {
    padding: 1rem;
    font-size: 0.9rem;
  }
  
  .btn {
    padding: 0.875rem 1.5rem;
    font-size: 0.9rem;
  }
  
  .form-group input,
  .form-group textarea,
  .form-group select {
    padding: 0.875rem 1rem;
  }
}

/* Accessibility */
@media (prefers-reduced-motion: reduce) {
  *,
  *::before,
  *::after {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }
  
  .floating-orb {
    animation: none;
  }
}

/* Focus Management */
*:focus {
  outline: 2px solid var(--primary);
  outline-offset: 2px;
}

/* Selection Styling */
::selection {
  background: var(--primary);
  color: white;
}

/* Scrollbar Styling */
::-webkit-scrollbar {
  width: 8px;
}

::-webkit-scrollbar-track {
  background: var(--surface-glass);
}

::-webkit-scrollbar-thumb {
  background: var(--primary);
  border-radius: var(--radius-sm);
}

::-webkit-scrollbar-thumb:hover {
  background: var(--primary-dark);
}

/* Firefox */
* {
  scrollbar-width: thin;
  scrollbar-color: var(--primary) var(--surface-glass);
}
</style>
</head>
<body>

<!-- Enhanced Background Animation -->
<div class="bg-animation">
  <div class="floating-orb orb-1"></div>
  <div class="floating-orb orb-2"></div>
  <div class="floating-orb orb-3"></div>
</div>

<!-- Login Modal -->
<div id="loginModal" class="login-modal">
  <div class="login-form">
    <h2>üîê Admin Access</h2>
    <form id="loginForm">
      <div class="form-group">
        <label for="username">üë§ Username</label>
        <input type="text" id="username" required autocomplete="username" placeholder="Enter admin username">
      </div>
      <div class="form-group">
        <label for="password">üîë Password</label>
        <input type="password" id="password" required autocomplete="current-password" placeholder="Enter admin password">
      </div>
      <button type="submit" class="login-btn" id="loginBtn">
        <span>üöÄ Login</span>
      </button>
    </form>
  </div>
</div>

<!-- Main Container -->
<div class="main-container" id="mainContainer" style="display: none; margin: 2rem;">
  <!-- Header -->
  <div class="header">
    <h1>üéå Admin Dashboard</h1>
    <p>Complete anime collection management system</p>
    <button id="logoutBtn" class="logout-btn">üö™ Logout</button>
  </div>
  
  <div class="content">
    <!-- Enhanced Statistics -->
    <div class="stats-container">
      <div class="stat-card">
        <h3 id="totalAnime">0</h3>
        <p>Total Anime</p>
      </div>
      <div class="stat-card">
        <h3 id="ongoingAnime">0</h3>
        <p>Ongoing Series</p>
      </div>
      <div class="stat-card">
        <h3 id="completedAnime">0</h3>
        <p>Completed Series</p>
      </div>
      <div class="stat-card">
        <h3 id="totalEpisodes">0</h3>
        <p>Total Episodes</p>
      </div>
    </div>

    <!-- Enhanced Tabs -->
    <div class="tabs">
      <button class="tab active" onclick="switchTab('list')">
        <span>üìã Browse Collection</span>
      </button>
      <button class="tab" onclick="switchTab('add')">
        <span>‚ûï Add New Anime</span>
      </button>
      <button class="tab" onclick="switchTab('edit')">
        <span>‚úèÔ∏è Edit Existing</span>
      </button>
      <button class="tab" onclick="switchTab('manage')">
        <span>‚öôÔ∏è System Settings</span>
      </button>
    </div>
    
    <!-- Tab: Browse Collection -->
    <div id="tab-list" class="tab-content active">
      <!-- Enhanced Search & Filter -->
      <div class="search-filter">
        <div class="filter-grid">
          <div class="form-group">
            <label for="search-input">üîç Search Anime</label>
            <input type="text" id="search-input" placeholder="Search by title, genre, or description...">
          </div>
          <div class="form-group">
            <label for="filter-status">üìä Filter Status</label>
            <select id="filter-status">
              <option value="">All Status</option>
              <option value="Ongoing">Ongoing</option>
              <option value="Complete">Complete</option>
            </select>
          </div>
          <div class="form-group">
            <label for="sort-by">üìà Sort By</label>
            <select id="sort-by">
              <option value="title">Title A-Z</option>
              <option value="year">Year (Newest)</option>
              <option value="rating">Rating (Highest)</option>
              <option value="episodes">Episodes (Most)</option>
              <option value="newest">Recently Added</option>
            </select>
          </div>
          <div class="form-group">
            <label>&nbsp;</label>
            <button class="btn btn-success" onclick="resetFilter()">üîÑ Reset</button>
          </div>
        </div>
      </div>
      
      <div id="loading" class="loading" style="display: none;">
        <div class="loading-spinner"></div>
        <p>Loading anime collection...</p>
      </div>
      <div id="anime-list" class="anime-list"></div>
    </div>
    
    <!-- Tab: Add New Anime -->
    <div id="tab-add" class="tab-content">
      <form id="add-form">
        <div class="form-group">
          <label for="title">üé¨ Anime Title *</label>
          <input type="text" id="title" required placeholder="Enter anime title">
        </div>
        
        <div class="form-group">
          <label for="thumb">üñºÔ∏è Thumbnail URL</label>
          <input type="url" id="thumb" placeholder="https://example.com/image.jpg">
        </div>
        
        <div class="form-group">
          <label for="status">üìä Status *</label>
          <select id="status" required>
            <option value="">Select Status</option>
            <option value="Ongoing">Ongoing</option>
            <option value="Complete">Complete</option>
          </select>
        </div>
        
        <div class="form-group">
          <label for="year">üìÖ Release Year</label>
          <input type="number" id="year" min="1900" max="2030" placeholder="2024">
        </div>
        
        <div class="form-group">
          <label for="genre">üé≠ Genres</label>
          <input type="text" id="genre" placeholder="Action, Adventure, Fantasy">
        </div>
        
        <div class="form-group">
          <label for="rating">‚≠ê Rating (0-10)</label>
          <input type="number" id="rating" step="0.1" min="0" max="10" placeholder="8.5">
        </div>
        
        <div class="form-group">
          <label for="description">üìù Description</label>
          <textarea id="description" rows="4" placeholder="Brief description of the anime..."></textarea>
        </div>
        
        <!-- Enhanced Episode Management -->
        <div class="episode-form">
          <h3>üì∫ Episode Management</h3>
          <div class="form-group">
            <label for="episode-title">Episode Title</label>
            <input type="text" id="episode-title" placeholder="Episode 1: The Beginning">
          </div>
          <div class="form-group">
            <label for="episode-url">Episode URL *</label>
            <input type="url" id="episode-url" placeholder="https://streaming-url.com/episode1" required>
          </div>
          <button type="button" class="btn btn-success" onclick="addEpisode()">
            <span>‚ûï Add Episode</span>
          </button>
          <div id="episode-list" class="episode-list"></div>
        </div>
        
        <div style="margin-top: 2rem; display: flex; gap: 1rem; flex-wrap: wrap;">
          <button type="submit" class="btn">
            <span>üíæ Save Anime</span>
          </button>
          <button type="button" class="btn btn-danger" onclick="resetForm()">
            <span>üóëÔ∏è Clear Form</span>
          </button>
        </div>
      </form>
    </div>
    
    <!-- Tab: Edit Existing -->
    <div id="tab-edit" class="tab-content">
      <div class="form-group">
        <label for="edit-select">Select Anime to Edit:</label>
        <select id="edit-select">
          <option value="">-- Choose an anime to edit --</option>
        </select>
      </div>
      
      <form id="edit-form" style="display: none;">
        <input type="hidden" id="edit-id">
        
        <div class="form-group">
          <label for="edit-title">üé¨ Anime Title *</label>
          <input type="text" id="edit-title" required>
        </div>
        
        <div class="form-group">
          <label for="edit-thumb">üñºÔ∏è Thumbnail URL</label>
          <input type="url" id="edit-thumb">
        </div>
        
        <div class="form-group">
          <label for="edit-status">üìä Status *</label>
          <select id="edit-status" required>
            <option value="">Select Status</option>
            <option value="Ongoing">Ongoing</option>
            <option value="Complete">Complete</option>
          </select>
        </div>
        
        <div class="form-group">
          <label for="edit-year">üìÖ Release Year</label>
          <input type="number" id="edit-year" min="1900" max="2030">
        </div>
        
        <div class="form-group">
          <label for="edit-genre">üé≠ Genres</label>
          <input type="text" id="edit-genre">
        </div>
        
        <div class="form-group">
          <label for="edit-rating">‚≠ê Rating (0-10)</label>
          <input type="number" id="edit-rating" step="0.1" min="0" max="10">
        </div>
        
        <div class="form-group">
          <label for="edit-description">üìù Description</label>
          <textarea id="edit-description" rows="4"></textarea>
        </div>
        
        <!-- Episode Management for Editing -->
        <div class="episode-form">
          <h3>üì∫ Episode Management</h3>
          <div id="edit-episode-list" class="episode-list"></div>
          <div class="form-group">
            <label for="new-episode-title">Add New Episode</label>
            <input type="text" id="new-episode-title" placeholder="New episode title">
          </div>
          <div class="form-group">
            <input type="url" id="new-episode-url" placeholder="https://streaming-url.com/new-episode">
          </div>
          <button type="button" class="btn btn-success" onclick="addNewEpisode()">
            <span>‚ûï Add Episode</span>
          </button>
        </div>
        
        <div style="margin-top: 2rem; display: flex; gap: 1rem; flex-wrap: wrap;">
          <button type="submit" class="btn">
            <span>üíæ Update Anime</span>
          </button>
          <button type="button" class="btn btn-danger" onclick="cancelEdit()">
            <span>‚ùå Cancel</span>
          </button>
        </div>
      </form>
    </div>
    
    <!-- Tab: System Settings -->
    <div id="tab-manage" class="tab-content">
      <div class="form-group">
        <label for="jsonbin-url">üåê JSONBin API URL</label>
        <input type="url" id="jsonbin-url" value="https://api.jsonbin.io/v3/b/68c7fdc9d0ea881f407e85cc" readonly>
      </div>
      <div class="form-group">
        <label for="jsonbin-key">üîë Master Key (Hidden for security)</label>
        <input type="password" id="jsonbin-key" value="$2a$10$PsVzgljojE5fq8qZRmpE4uzMr0K9LArqfmumGVSmNY.P8F2iTKrim" readonly>
      </div>
      
      <div style="display: flex; gap: 1rem; flex-wrap: wrap; margin-top: 2rem;">
        <button class="btn" onclick="testConnection()">
          <span>üîó Test Connection</span>
        </button>
        <button class="btn btn-success" onclick="exportData()">
          <span>üì§ Export Data</span>
        </button>
        <button class="btn" onclick="importData()">
          <span>üì• Import Data</span>
        </button>
        <button class="btn btn-danger" onclick="clearAllData()">
          <span>üóëÔ∏è Clear All Data</span>
        </button>
      </div>
      <input type="file" id="import-file" accept=".json" style="display: none;" onchange="handleImportFile(event)">
    </div>
  </div>
</div>

<!-- Toast Container -->
<div id="toast-container" class="toast-container"></div>

<script>
// Enhanced Configuration
const ADMIN_CONFIG = {
  USERNAME: "admin",
  PASSWORD: "hanzyy001",
  JSONBIN_URL: "https://api.jsonbin.io/v3/b/68c7fdc9d0ea881f407e85cc",
  JSONBIN_KEY: "$2a$10$PsVzgljojE5fq8qZRmpE4uzMr0K9LArqfmumGVSmNY.P8F2iTKrim"
};

// Global State
let tempEpisodes = [];
let editEpisodes = [];
let allAnimeData = [];
let isLoggedIn = false;

// Enhanced Notification System
class NotificationManager {
  static show(message, type = 'info', duration = 4000) {
    const container = this.getContainer();
    
    const toast = document.createElement('div');
    toast.className = `toast ${type}`;
    toast.innerHTML = `
      <div style="display: flex; align-items: center; gap: 0.75rem;">
        <span style="font-size: 1.25rem;">${this.getIcon(type)}</span>
        <span>${message}</span>
      </div>
    `;
    
    container.appendChild(toast);

    setTimeout(() => {
      if (toast.parentNode) {
        toast.style.animation = 'slideIn 0.3s ease reverse';
        setTimeout(() => toast.remove(), 300);
      }
    }, duration);
  }

  static getIcon(type) {
    const icons = {
      success: '‚úÖ',
      error: '‚ùå',
      warning: '‚ö†Ô∏è',
      info: '‚ÑπÔ∏è'
    };
    return icons[type] || icons.info;
  }

  static getContainer() {
    let container = document.getElementById('toast-container');
    if (!container) {
      container = document.createElement('div');
      container.id = 'toast-container';
      container.className = 'toast-container';
      document.body.appendChild(container);
    }
    return container;
  }
}

// Enhanced Data Manager
class DataManager {
  static async getData() {
    try {
      const response = await fetch(`${ADMIN_CONFIG.JSONBIN_URL}/latest`, {
        headers: { "X-Master-Key": ADMIN_CONFIG.JSONBIN_KEY }
      });
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      const data = await response.json();
      return data.record || [];
    } catch (error) {
      console.error('Error fetching data:', error);
      NotificationManager.show('Failed to load data from JSONBin', 'error');
      return [];
    }
  }

  static async updateData(newData) {
    try {
      const response = await fetch(ADMIN_CONFIG.JSONBIN_URL, {
        method: 'PUT',
        headers: { 
          "X-Master-Key": ADMIN_CONFIG.JSONBIN_KEY, 
          "Content-Type": "application/json" 
        },
        body: JSON.stringify(newData)
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      return true;
    } catch (error) {
      console.error('Error updating data:', error);
      NotificationManager.show('Failed to save data to JSONBin', 'error');
      return false;
    }
  }

  static validateAnimeData(anime) {
    const errors = [];
    
    if (!anime.title || anime.title.trim().length === 0) {
      errors.push('Title is required');
    }
    
    if (!anime.status) {
      errors.push('Status is required');
    }
    
    if (anime.year && (anime.year < 1900 || anime.year > 2030)) {
      errors.push('Year must be between 1900 and 2030');
    }
    
    if (anime.rating && (anime.rating < 0 || anime.rating > 10)) {
      errors.push('Rating must be between 0 and 10');
    }
    
    if (anime.episodes && anime.episodes.some(ep => !ep.src)) {
      errors.push('All episodes must have a valid streaming URL');
    }

    return errors;
  }
}

// Enhanced Authentication System
class AuthManager {
  static checkAuth() {
    const isLoggedIn = sessionStorage.getItem('admin_logged_in');
    if (isLoggedIn === 'true') {
      this.showMainContent();
    } else {
      this.showLoginModal();
    }
  }
  
  static showLoginModal() {
    document.getElementById('loginModal').style.display = 'flex';
    document.getElementById('mainContainer').style.display = 'none';
    
    // Focus username field
    setTimeout(() => {
      document.getElementById('username').focus();
    }, 100);
  }
  
  static showMainContent() {
    document.getElementById('loginModal').style.display = 'none';
    document.getElementById('mainContainer').style.display = 'block';
    AdminController.loadAnimeList();
    AdminController.updateStatistics();
    AdminController.loadEditOptions();
    isLoggedIn = true;
  }
  
  static login(username, password) {
    // Show loading state
    const loginBtn = document.getElementById('loginBtn');
    const originalText = loginBtn.innerHTML;
    loginBtn.innerHTML = '<span>üîÑ Logging in...</span>';
    loginBtn.disabled = true;

    // Simulate loading delay for better UX
    setTimeout(() => {
      if (username === ADMIN_CONFIG.USERNAME && password === ADMIN_CONFIG.PASSWORD) {
        sessionStorage.setItem('admin_logged_in', 'true');
        this.showMainContent();
        NotificationManager.show('Login successful! Welcome back, Admin.', 'success');
      } else {
        // Show detailed error message
        if (!username) {
          NotificationManager.show('Please enter your username', 'error');
        } else if (!password) {
          NotificationManager.show('Please enter your password', 'error');
        } else if (username !== ADMIN_CONFIG.USERNAME) {
          NotificationManager.show('Invalid username! Please check your credentials.', 'error');
        } else if (password !== ADMIN_CONFIG.PASSWORD) {
          NotificationManager.show('Incorrect password! Please try again.', 'error');
        } else {
          NotificationManager.show('Invalid username or password!', 'error');
        }
        
        // Shake animation for login form
        const loginForm = document.querySelector('.login-form');
        loginForm.style.animation = 'shake 0.5s ease-in-out';
        setTimeout(() => {
          loginForm.style.animation = '';
        }, 500);
      }

      // Reset button state
      loginBtn.innerHTML = originalText;
      loginBtn.disabled = false;
    }, 1000);
  }
  
  static logout() {
    sessionStorage.removeItem('admin_logged_in');
    isLoggedIn = false;
    this.showLoginModal();
    NotificationManager.show('Successfully logged out. See you next time!', 'success');
    
    // Clear form data
    document.getElementById('username').value = '';
    document.getElementById('password').value = '';
  }
}

// Enhanced Admin Controller
class AdminController {
  static async loadAnimeList() {
    const loading = document.getElementById('loading');
    const animeList = document.getElementById('anime-list');
    
    if (loading) loading.style.display = 'block';
    if (animeList) animeList.style.display = 'none';
    
    allAnimeData = await DataManager.getData();
    
    if (loading) loading.style.display = 'none';
    if (animeList) animeList.style.display = 'grid';
    
    this.renderAnimeList(allAnimeData);
    this.updateStatistics();
  }

  static renderAnimeList(data) {
    const animeList = document.getElementById('anime-list');
    if (!animeList) return;
    
    if (data.length === 0) {
      animeList.innerHTML = `
        <div style="grid-column: 1/-1; text-align: center; padding: 3rem; color: var(--text-secondary);">
          <div style="font-size: 3rem; margin-bottom: 1rem;">üì∫</div>
          <h3>No anime found</h3>
          <p>Start by adding your first anime to the collection!</p>
        </div>
      `;
      return;
    }
    
    animeList.innerHTML = data.map(anime => {
      const statusClass = anime.status?.toLowerCase() === 'ongoing' ? 'status-ongoing' : 'status-complete';
      const episodeCount = anime.episodes ? anime.episodes.length : 0;
      const truncatedTitle = this.truncateText(anime.title, 40);
      const truncatedDesc = this.truncateText(anime.description, 100);
      
      return `
        <div class="anime-card">
          <h3 title="${anime.title}">${truncatedTitle}</h3>
          <div class="anime-meta">
            <span class="status-badge ${statusClass}">${anime.status || 'Unknown'}</span>
            <span class="episodes-count">${episodeCount} Episodes</span>
          </div>
          <div class="anime-meta">
            <span><strong>Year:</strong> ${anime.year || 'N/A'}</span>
            <span><strong>Rating:</strong> ${anime.rating ? '‚≠ê ' + anime.rating : 'N/A'}</span>
          </div>
          ${anime.genre ? `<div><strong>Genre:</strong> ${this.truncateText(anime.genre, 50)}</div>` : ''}
          <div class="anime-description">
            ${truncatedDesc}
          </div>
          <div style="margin-top: 1.5rem; display: flex; gap: 0.75rem; flex-wrap: wrap;">
            <button class="btn" onclick="AdminController.editAnime(${anime.id})" style="flex: 1; min-width: 100px;">
              <span>‚úèÔ∏è Edit</span>
            </button>
            <button class="btn btn-danger" onclick="AdminController.deleteAnime(${anime.id})" style="flex: 1; min-width: 100px;">
              <span>üóëÔ∏è Delete</span>
            </button>
          </div>
          <small style="color: var(--text-muted); margin-top: 1rem; display: block;">ID: ${anime.id}</small>
        </div>
      `;
    }).join('');
  }

  static updateStatistics() {
    const totalAnime = allAnimeData.length;
    const ongoingAnime = allAnimeData.filter(a => a.status === 'Ongoing').length;
    const completedAnime = allAnimeData.filter(a => a.status === 'Complete').length;
    const totalEpisodes = allAnimeData.reduce((sum, anime) => sum + (anime.episodes ? anime.episodes.length : 0), 0);
    
    this.animateCounter('totalAnime', totalAnime);
    this.animateCounter('ongoingAnime', ongoingAnime);
    this.animateCounter('completedAnime', completedAnime);
    this.animateCounter('totalEpisodes', totalEpisodes);
  }

  static animateCounter(elementId, target, duration = 1500) {
    const element = document.getElementById(elementId);
    if (!element) return;
    
    const start = 0;
    const startTime = performance.now();
    
    const updateCounter = (currentTime) => {
      const elapsed = currentTime - startTime;
      const progress = Math.min(elapsed / duration, 1);
      
      const easeOutQuart = 1 - Math.pow(1 - progress, 4);
      const current = Math.floor(start + (target - start) * easeOutQuart);
      
      element.textContent = current.toLocaleString();
      
      if (progress < 1) {
        requestAnimationFrame(updateCounter);
      } else {
        element.textContent = target.toLocaleString();
      }
    };
    
    requestAnimationFrame(updateCounter);
  }

  static applyFilters() {
    const searchTerm = document.getElementById('search-input')?.value.toLowerCase() || '';
    const statusFilter = document.getElementById('filter-status')?.value || '';
    const sortBy = document.getElementById('sort-by')?.value || 'title';
    
    let filteredData = [...allAnimeData];
    
    // Apply search filter
    if (searchTerm) {
      filteredData = filteredData.filter(anime => 
        anime.title.toLowerCase().includes(searchTerm) ||
        (anime.genre && anime.genre.toLowerCase().includes(searchTerm)) ||
        (anime.description && anime.description.toLowerCase().includes(searchTerm))
      );
    }
    
    // Apply status filter
    if (statusFilter) {
      filteredData = filteredData.filter(anime => anime.status === statusFilter);
    }
    
    // Apply sorting
    filteredData.sort((a, b) => {
      switch (sortBy) {
        case 'title':
          return a.title.localeCompare(b.title);
        case 'year':
          return (b.year || 0) - (a.year || 0);
        case 'rating':
          return (b.rating || 0) - (a.rating || 0);
        case 'episodes':
          return (b.episodes?.length || 0) - (a.episodes?.length || 0);
        case 'newest':
          return new Date(b.createdAt || 0) - new Date(a.createdAt || 0);
        default:
          return 0;
      }
    });
    
    this.renderAnimeList(filteredData);
  }

  static async deleteAnime(id) {
    const anime = allAnimeData.find(a => a.id === id);
    if (!anime) return;
    
    if (!confirm(`Are you sure you want to delete "${anime.title}"?\n\nThis action cannot be undone.`)) {
      return;
    }
    
    const filteredData = allAnimeData.filter(anime => anime.id !== id);
    
    if (await DataManager.updateData(filteredData)) {
      NotificationManager.show(`"${anime.title}" deleted successfully`, 'success');
      this.loadAnimeList();
      this.loadEditOptions();
    }
  }

  static editAnime(id) {
    switchTab('edit');
    document.getElementById('edit-select').value = id;
    this.loadEditForm(id);
  }

  static async loadEditOptions() {
    const data = await DataManager.getData();
    const select = document.getElementById('edit-select');
    if (!select) return;
    
    select.innerHTML = '<option value="">-- Choose an anime to edit --</option>';
    
    data.forEach(anime => {
      const option = document.createElement('option');
      option.value = anime.id;
      option.textContent = `${anime.title} (${anime.status || 'Unknown'}) - ${anime.episodes?.length || 0} Episodes`;
      select.appendChild(option);
    });
  }

  static async loadEditForm(id) {
    if (!id) {
      document.getElementById('edit-form').style.display = 'none';
      return;
    }
    
    const data = await DataManager.getData();
    const anime = data.find(a => a.id == id);
    
    if (!anime) {
      NotificationManager.show('Anime not found', 'error');
      return;
    }
    
    // Populate form fields
    document.getElementById('edit-id').value = anime.id;
    document.getElementById('edit-title').value = anime.title;
    document.getElementById('edit-thumb').value = anime.thumb || '';
    document.getElementById('edit-status').value = anime.status;
    document.getElementById('edit-year').value = anime.year || '';
    document.getElementById('edit-genre').value = anime.genre || '';
    document.getElementById('edit-rating').value = anime.rating || '';
    document.getElementById('edit-description').value = anime.description || '';
    
    editEpisodes = [...(anime.episodes || [])];
    this.updateEditEpisodeList();
    
    document.getElementById('edit-form').style.display = 'block';
  }

  static updateEditEpisodeList() {
    const episodeList = document.getElementById('edit-episode-list');
    if (!episodeList) return;
    
    episodeList.innerHTML = editEpisodes.map((episode, index) => `
      <div class="episode-item">
        <div>
          <strong>Episode ${episode.num}:</strong> ${episode.title || 'No title'}
          <br>
          <small style="color: var(--text-muted);">${this.truncateText(episode.src, 60)}</small>
        </div>
        <button class="btn btn-danger" style="padding: 0.5rem 1rem; font-size: 0.875rem;" onclick="AdminController.removeEditEpisode(${index})">
          <span>üóëÔ∏è</span>
        </button>
      </div>
    `).join('');
  }

  static removeEditEpisode(index) {
    editEpisodes.splice(index, 1);
    editEpisodes.forEach((ep, i) => ep.num = i + 1);
    this.updateEditEpisodeList();
    NotificationManager.show('Episode removed', 'success');
  }

  static truncateText(text, maxLength) {
    if (!text) return 'No data';
    return text.length > maxLength ? text.substring(0, maxLength) + '...' : text;
  }
}

// Episode Management Functions
function addEpisode() {
  const title = document.getElementById('episode-title').value.trim();
  const url = document.getElementById('episode-url').value.trim();
  
  if (!url) {
    NotificationManager.show('Episode URL is required', 'error');
    return;
  }
  
  try {
    new URL(url); // Validate URL
  } catch {
    NotificationManager.show('Please enter a valid URL', 'error');
    return;
  }
  
  tempEpisodes.push({
    num: tempEpisodes.length + 1,
    title: title || `Episode ${tempEpisodes.length + 1}`,
    src: url
  });
  
  updateEpisodeList();
  
  document.getElementById('episode-title').value = '';
  document.getElementById('episode-url').value = '';
  
  NotificationManager.show('Episode added successfully', 'success');
}

function updateEpisodeList() {
  const episodeList = document.getElementById('episode-list');
  if (!episodeList) return;
  
  episodeList.innerHTML = tempEpisodes.map((episode, index) => `
    <div class="episode-item">
      <div>
        <strong>Episode ${episode.num}:</strong> ${episode.title}
        <br>
        <small style="color: var(--text-muted);">${AdminController.truncateText(episode.src, 60)}</small>
      </div>
      <button class="btn btn-danger" style="padding: 0.5rem 1rem; font-size: 0.875rem;" onclick="removeEpisode(${index})">
        <span>üóëÔ∏è</span>
      </button>
    </div>
  `).join('');
}

function removeEpisode(index) {
  tempEpisodes.splice(index, 1);
  tempEpisodes.forEach((ep, i) => ep.num = i + 1);
  updateEpisodeList();
  NotificationManager.show('Episode removed', 'success');
}

function addNewEpisode() {
  const title = document.getElementById('new-episode-title').value.trim();
  const url = document.getElementById('new-episode-url').value.trim();
  
  if (!url) {
    NotificationManager.show('Episode URL is required', 'error');
    return;
  }
  
  try {
    new URL(url); // Validate URL
  } catch {
    NotificationManager.show('Please enter a valid URL', 'error');
    return;
  }
  
  editEpisodes.push({
    num: editEpisodes.length + 1,
    title: title || `Episode ${editEpisodes.length + 1}`,
    src: url
  });
  
  AdminController.updateEditEpisodeList();
  
  document.getElementById('new-episode-title').value = '';
  document.getElementById('new-episode-url').value = '';
  
  NotificationManager.show('Episode added successfully', 'success');
}

function resetForm() {
  document.getElementById('add-form').reset();
  tempEpisodes = [];
  updateEpisodeList();
  NotificationManager.show('Form cleared', 'success');
}

function resetFilter() {
  const searchInput = document.getElementById('search-input');
  const filterStatus = document.getElementById('filter-status');
  const sortBy = document.getElementById('sort-by');
  
  if (searchInput) searchInput.value = '';
  if (filterStatus) filterStatus.value = '';
  if (sortBy) sortBy.value = 'title';
  
  AdminController.renderAnimeList(allAnimeData);
  NotificationManager.show('Filters reset', 'success');
}

function cancelEdit() {
  document.getElementById('edit-form').style.display = 'none';
  document.getElementById('edit-select').value = '';
  editEpisodes = [];
  NotificationManager.show('Edit cancelled', 'info');
}

// Tab Management
function switchTab(tabName) {
  // Remove active class from all tabs and contents
  document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
  document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
  
  // Add active class to clicked tab and corresponding content
  event.target.classList.add('active');
  document.getElementById(`tab-${tabName}`).classList.add('active');
  
  // Load data for specific tabs
  if (tabName === 'list') {
    AdminController.loadAnimeList();
  } else if (tabName === 'edit') {
    AdminController.loadEditOptions();
  }
}

// System Management Functions
async function testConnection() {
  try {
    NotificationManager.show('Testing connection...', 'info');
    const response = await fetch(`${ADMIN_CONFIG.JSONBIN_URL}/latest`, {
      headers: { "X-Master-Key": ADMIN_CONFIG.JSONBIN_KEY }
    });
    
    if (response.ok) {
      NotificationManager.show('Connection successful! JSONBin is working properly.', 'success');
    } else {
      throw new Error(`HTTP ${response.status}`);
    }
  } catch (error) {
    NotificationManager.show('Connection failed! Please check your settings.', 'error');
  }
}

async function clearAllData() {
  if (!confirm('‚ö†Ô∏è WARNING: This will permanently delete ALL anime data!\n\nThis action cannot be undone. Are you absolutely sure?')) {
    return;
  }
  
  if (!confirm('This is your final warning. All anime and episode data will be lost forever. Continue?')) {
    return;
  }
  
  if (await DataManager.updateData([])) {
    NotificationManager.show('All data cleared successfully', 'success');
    AdminController.loadAnimeList();
    AdminController.loadEditOptions();
  }
}

function exportData() {
  try {
    const dataStr = JSON.stringify(allAnimeData, null, 2);
    const dataBlob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement('a');
    
    link.href = url;
    link.download = `dongtube-anime-data-${new Date().toISOString().split('T')[0]}.json`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
    
    NotificationManager.show('Data exported successfully!', 'success');
  } catch (error) {
    console.error('Export error:', error);
    NotificationManager.show('Failed to export data', 'error');
  }
}

function importData() {
  document.getElementById('import-file').click();
}

async function handleImportFile(event) {
  const file = event.target.files[0];
  if (!file) return;
  
  try {
    const text = await file.text();
    const importedData = JSON.parse(text);
    
    // Validate imported data
    if (!Array.isArray(importedData)) {
      throw new Error('Invalid data format: Expected an array');
    }
    
    // Basic validation of anime objects
    for (const anime of importedData) {
      const errors = DataManager.validateAnimeData(anime);
      if (errors.length > 0) {
        throw new Error(`Invalid anime data: ${errors.join(', ')}`);
      }
    }
    
    if (await DataManager.updateData(importedData)) {
      NotificationManager.show(`Successfully imported ${importedData.length} anime!`, 'success');
      AdminController.loadAnimeList();
      AdminController.loadEditOptions();
    }
  } catch (error) {
    console.error('Import error:', error);
    NotificationManager.show(`Import failed: ${error.message}`, 'error');
  }
  
  // Reset file input
  event.target.value = '';
}

// Enhanced Form Event Handlers
document.addEventListener('DOMContentLoaded', () => {
  // Check authentication
  AuthManager.checkAuth();
  
  // Login form handler
  document.getElementById('loginForm').addEventListener('submit', (e) => {
    e.preventDefault();
    const username = document.getElementById('username').value.trim();
    const password = document.getElementById('password').value.trim();
    AuthManager.login(username, password);
  });
  
  // Logout handler
  document.getElementById('logoutBtn').addEventListener('click', () => {
    if (confirm('Are you sure you want to logout?')) {
      AuthManager.logout();
    }
  });
  
  // Add form handler
  document.getElementById('add-form').addEventListener('submit', async (e) => {
    e.preventDefault();
    
    const formData = {
      id: Date.now(), // Simple ID generation
      title: document.getElementById('title').value.trim(),
      thumb: document.getElementById('thumb').value.trim(),
      status: document.getElementById('status').value,
      year: parseInt(document.getElementById('year').value) || null,
      genre: document.getElementById('genre').value.trim(),
      rating: parseFloat(document.getElementById('rating').value) || null,
      description: document.getElementById('description').value.trim(),
      episodes: [...tempEpisodes],
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    };
    
    // Validate data
    const errors = DataManager.validateAnimeData(formData);
    if (errors.length > 0) {
      NotificationManager.show(`Validation error: ${errors.join(', ')}`, 'error');
      return;
    }
    
    // Check for duplicate titles
    if (allAnimeData.some(anime => anime.title.toLowerCase() === formData.title.toLowerCase())) {
      NotificationManager.show('An anime with this title already exists!', 'error');
      return;
    }
    
    const data = await DataManager.getData();
    data.push(formData);
    
    if (await DataManager.updateData(data)) {
      NotificationManager.show(`"${formData.title}" added successfully!`, 'success');
      resetForm();
      switchTab('list');
      AdminController.loadEditOptions();
    }
  });
  
  // Edit form handler
  document.getElementById('edit-form').addEventListener('submit', async (e) => {
    e.preventDefault();
    
    const formData = {
      id: parseInt(document.getElementById('edit-id').value),
      title: document.getElementById('edit-title').value.trim(),
      thumb: document.getElementById('edit-thumb').value.trim(),
      status: document.getElementById('edit-status').value,
      year: parseInt(document.getElementById('edit-year').value) || null,
      genre: document.getElementById('edit-genre').value.trim(),
      rating: parseFloat(document.getElementById('edit-rating').value) || null,
      description: document.getElementById('edit-description').value.trim(),
      episodes: [...editEpisodes],
      updatedAt: new Date().toISOString()
    };
    
    // Validate data
    const errors = DataManager.validateAnimeData(formData);
    if (errors.length > 0) {
      NotificationManager.show(`Validation error: ${errors.join(', ')}`, 'error');
      return;
    }
    
    const data = await DataManager.getData();
    const index = data.findIndex(anime => anime.id === formData.id);
    
    if (index !== -1) {
      // Preserve original creation date
      formData.createdAt = data[index].createdAt;
      data[index] = formData;
      
      if (await DataManager.updateData(data)) {
        NotificationManager.show(`"${formData.title}" updated successfully!`, 'success');
        cancelEdit();
        AdminController.loadAnimeList();
      }
    } else {
      NotificationManager.show('Anime not found for update', 'error');
    }
  });
  
  // Edit select handler
  document.getElementById('edit-select').addEventListener('change', (e) => {
    AdminController.loadEditForm(e.target.value);
  });
  
  // Search and filter handlers
  const searchInput = document.getElementById('search-input');
  const filterStatus = document.getElementById('filter-status');
  const sortBy = document.getElementById('sort-by');
  
  if (searchInput) {
    let searchTimeout;
    searchInput.addEventListener('input', () => {
      clearTimeout(searchTimeout);
      searchTimeout = setTimeout(() => AdminController.applyFilters(), 300);
    });
  }
  
  if (filterStatus) {
    filterStatus.addEventListener('change', () => AdminController.applyFilters());
  }
  
  if (sortBy) {
    sortBy.addEventListener('change', () => AdminController.applyFilters());
  }
  
  // Keyboard shortcuts
  document.addEventListener('keydown', (e) => {
    if (!isLoggedIn) return;
    
    if (e.ctrlKey || e.metaKey) {
      switch (e.key) {
        case 's':
        case 'S':
          e.preventDefault();
          // Save current form if any tab is active
          const activeTab = document.querySelector('.tab.active');
          if (activeTab) {
            const tabName = activeTab.onclick.toString().match(/switchTab\('(.+)'\)/)?.[1];
            if (tabName === 'add') {
              document.getElementById('add-form').dispatchEvent(new Event('submit'));
            } else if (tabName === 'edit') {
              document.getElementById('edit-form').dispatchEvent(new Event('submit'));
            }
          }
          break;
        case 'f':
        case 'F':
          e.preventDefault();
          searchInput?.focus();
          break;
      }
    }
  });
  
  // Enter key on login inputs
  document.getElementById('username').addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      document.getElementById('password').focus();
    }
  });
  
  document.getElementById('password').addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      document.getElementById('loginForm').dispatchEvent(new Event('submit'));
    }
  });
});

// Enhanced Error Handling
window.addEventListener('error', (event) => {
  console.error('Global error:', event.error);
  if (isLoggedIn) {
    NotificationManager.show('An unexpected error occurred. Please refresh the page.', 'error');
  }
});

window.addEventListener('unhandledrejection', (event) => {
  console.error('Unhandled promise rejection:', event.reason);
  if (isLoggedIn) {
    NotificationManager.show('Network error occurred. Please check your connection.', 'error');
  }
});

// Auto-save functionality
let autoSaveInterval;
function startAutoSave() {
  clearInterval(autoSaveInterval);
  autoSaveInterval = setInterval(() => {
    // Auto-save draft to localStorage (optional feature)
    const formData = {
      title: document.getElementById('title')?.value || '',
      thumb: document.getElementById('thumb')?.value || '',
      status: document.getElementById('status')?.value || '',
      year: document.getElementById('year')?.value || '',
      genre: document.getElementById('genre')?.value || '',
      rating: document.getElementById('rating')?.value || '',
      description: document.getElementById('description')?.value || '',
      episodes: [...tempEpisodes]
    };
    
    if (Object.values(formData).some(value => value && value.length > 0) || tempEpisodes.length > 0) {
      localStorage.setItem('dongtube_admin_draft', JSON.stringify(formData));
    }
  }, 30000); // Save every 30 seconds
}

// Load draft on page load
function loadDraft() {
  try {
    const draft = localStorage.getItem('dongtube_admin_draft');
    if (draft && isLoggedIn) {
      const formData = JSON.parse(draft);
      if (confirm('Found a saved draft. Would you like to restore it?')) {
        Object.keys(formData).forEach(key => {
          const element = document.getElementById(key);
          if (element && key !== 'episodes') {
            element.value = formData[key];
          }
        });
        
        if (formData.episodes) {
          tempEpisodes = [...formData.episodes];
          updateEpisodeList();
        }
        
        NotificationManager.show('Draft restored successfully', 'success');
      }
      localStorage.removeItem('dongtube_admin_draft');
    }
  } catch (error) {
    console.error('Error loading draft:', error);
  }
}

// Performance monitoring
const performanceObserver = new PerformanceObserver((list) => {
  for (const entry of list.getEntries()) {
    if (entry.entryType === 'navigation') {
      console.log(`Page load time: ${entry.loadEventEnd - entry.fetchStart}ms`);
    }
  }
});

if ('PerformanceObserver' in window) {
  performanceObserver.observe({ entryTypes: ['navigation'] });
}

// Initialize auto-save after login
setTimeout(() => {
  if (isLoggedIn) {
    loadDraft();
    startAutoSave();
  }
}, 1000);
</script>
</body>
</html>